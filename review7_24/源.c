#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<stdlib.h>

//void test() {
//	printf("hehe");
//}
//
//int main() {
//	test(100);//可以传 不用
//	return 0;
//}
//void test(void) {
//	printf("hehe");
//}
//
//int main() {
//	test(100);//不能传 必须为空  因为函数中用了void
//	return 0;
//}

//int main() {
//	int a = 20;
//	int b = -10;
//	system("pause");
//	return 0;
//}

//大端相异小端相同
//大端相异：数据高位存低地址  数据低位存高地址
//int check_sys()
//{
//	int a = 1;
//	/*char* p = (char*)&a;
//	if (*p == 1)
//		return 1;
//	else
//		return 0;*/
//
//
//		//  or
//
//
//	return (*(char*)&a);
//}
//
//int main()
//{
//	int ret = check_sys();
//	if (ret == 1)
//		printf("小端\n");
//	else
//		printf("大端\n");
//	system("pause");
//}
//int main()
//{
//	char a = -1;
//	10000000000000000000000000000001  -1再存进去之前是32bit
//	11111111111111111111111111111110  取反 符号位不变
//	11111111111111111111111111111111  补码 
//	11111111    因为是char类型只能存八个比特位 整形截断
//	 
//	打印a的时候得发生整形提升   因为char为有符号的char 所以整形提升高位补充符号位
//	11111111111111111111111111111111  补码
//	11111111111111111111111111111110  反码码
//	10000000000000000000000000000001  源码码
//	signed char b = -1;
//	11111111   
//	11111111111111111111111111111111  原理与上相同
//
//
//
//	unsigned char c = -1;
//	11111111    因为char为无符号的char所以整形提升高位补零
//	00000000000000000000000011111111
//
//	printf("%d %d %d", a, b, c);
//	return 0;
//}

int main()
{
	char a = -128; 
	                          
	//10000000000000000000000010000000
	//11111111111111111111111101111111
	//11111111111111111111111110000000 -补码
	//10000000 整形截断
	//11111111111111111111111110000000 - 整形提升 补码  这个例外 整形提升补1
	//由于是打印无符号的十进制数，所以补码即原码
	printf("%u\n", a);
	//%u  打印无符号的十进制数
	return 0;
}
