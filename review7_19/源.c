#define _CRT_SECURE_NO_WARNINGS 1

#include<stdio.h>
//详解操作符

//算术操作符
//+ - * / %
//int main() {	
//	int a = 5 / 2;//5/2 商2 余1
//	float b = 5/2.0;//
//	printf("%d\n", a); //2
//	printf("%lf\n", b); //2.500000 如果需要小数 需要用浮点型
//	//b %= 2;//浮点型能否使用%取模呢？ 不行！
//	// 1、除了%操作符外 其他几个操作符都能作用于整数和浮点数
//	// 2、对于/操作符 如果两个操作符都为整数，执行整数除法，而只要有浮点数执行的就是浮点数除法
//	// 3、取模%左右两边都必须为整数 两个数整除的余数
//	//printf("%lf\n", b);
//	return 0;
//}////左边丢弃，右边补零
////左移有乘2的效果
//int main()
//{
//	//注意：对于位移操作符，不要移动负数位，这个是标准未定义的。例如：
////	int num = 0;
//	//num >> -1;  //error
//	int b = 0;
//	int a = -5;
//	b = a << 1;
//
//	//00000000000000000000000000000101
//	//00000000000000000000000000001010  --5的左移 b成了10
//	printf("%d", b);
//	return 0;
//}
//
//位操作符（只能作用整数)
//& 按位与
//| 按位或
//^ 按位异或

//int main() {
//	//& 按二进制位&
//	int a = 3;
//	int b = 5;
//	int c = a & b;
////00000000000000000000000000000011    //二进制 3
////00000000000000000000000000000101    //二进制 5
////00000000000000000000000000000001    // a&b  有零为零，全1为1
//	printf("%d", c);
//	return 0;
//}


//按位或
//int main()
//{
//	//| - 按2进制位或
//	int a = 3;
//	int b = 5;
//	int c = a | b;
//	//00000000000000000000000000000011    //二进制 3
//	//00000000000000000000000000000101    //二进制 5
//	//00000000000000000000000000000111   // a|b  有1为1，全0为0
//	printf("%d\n", c);//结果为7
//	return 0;
//}

//int main()
//{
//	// ^ - 按2进制位或
//	int a = 3;
//	int b = 5;
//	int c = a ^ b;
//	//00000000000000000000000000000011    //二进制 3
//	//00000000000000000000000000000101    //二进制 5
//	//00000000000000000000000000000110   // a^b  相同为0，相异为1
//	printf("%d\n", c);//结果为6
//	return 0;
//}

//交换两个int 的值 不建   变量

//int main() {
//	int a = 3;
//	int b = 5;
//	//加减法   缺陷：可能会溢出
//	 a = a + b;//8
//	 b = a-b;//3
//	 a = a - b;//5
//	 printf("%d %d", a, b);
//}

//int main() {
//	int a = 3; //011
//	int b = 5;//101 
//	//任何数和0异或都是本身，任何数和自己异或都是0；所以上面的
//	//b = （a ^ b） ^ b就等于a(原来的a)
//	//异或运算有些性质：a^ a = 0   a ^ 0 = a 
//	//这个方法根据的就是这个性质
//	a = a ^ b;
//	b = a ^ b;
//	a = a ^ b;
//	printf("%d %d", a, b);
//}

//a=a^b             b=a^b;            a=a^b
//011                 110               110
//101                 101               011 
//110                 011               101
//a的二进制为 110     b的二进制为011   a的二进制为101

//计算十进制数换成二进制有多少个1
//int main() {
//	int num = 0;
//	scanf("%d", &num);
//	//统计num的补码有几个1
//	int count = 0;
//	while (num) {
//		if (num % 2 == 1)
//		{
//			count++;
//		}
//		num /=2;
//	}
//	printf("%d", count);
//	return 0;
//}
//模10除10能得到十进制的所有数
//模2除2能得到二进制所有数
//缺陷：只能求正数，不可求负数
//int main()
//{
//	int num = 0;
//	int count = 0;
//	scanf("%d", &num);
//	//00000000000000000000000000000101   32位
//	//00000000000000000000000000000001
//	//按位与 与 右移操作符一起
//	for (int i = 0; i < 32; i++)
//	{
//		if (num & 1 == 1)
//		{
//			count++;
//		}
//		num >> i;
//	}
//	printf("在二进制中有%d个1", count);
//	return 0;
//}

//赋值操作符可以连续使用
//int main() {
//	int a = 10;
//	int x = 0;
//	int y = 20;
//	a = x = y + 1;
//	printf("%d %d", a, x);
//}

//复合赋值符
//int main() {
//	int a = 10;
//	a = a + 2;
//	a += 2;//复合赋值符
//	a = a >> 1;
//	a >>= 1;
//	a = a & 1;
//	a &= 1;
//	return 0;
//}

//单目操作符


//!逻辑反操作
//int main()
//{
//	int a = 0;
//	if (!a)//a为假打印呵呵
//	{
//		printf("呵呵\n");
//	}
//	if (a)//如果a为真打印呵呵
//	{
//		printf("呵呵\n");
//	}
//}

//负值
//int main()
//{
//	int a = -5;
//	a = -a;
//	printf("%d", a);
//}
//

//& 取地址符
//int main()
//{
//	int a = 10;
//	int* p = &a;//取地址操作符
//	*p = 20;//解引用操作符
//	printf("%d", a);
//	return 0;
//}

//sizeof  操作数类型的长度
int main()
{
	int a = 10;
      short s=0;
	char c = 'r';
	char* p = &c;
	int arr[10] = { 0 };
    printf("%d\n",sizeof(s=a+5));//结果为2，因为s是short类型所以为2
    printf("%d\n",s);/*因为s=0*/ //sizeof() 是不会进行增值运算 所以a+5只是摆设
	//sizeof  计算变量所占内存空间大小，单位是字节
	printf("%d\n", sizeof(int));//4
	printf("%d\n", sizeof(a));//4


	printf("%d\n", sizeof(c));//1
	printf("%d\n", sizeof(char));//1

	printf("%d\n", sizeof(p));//4
	printf("%d\n", sizeof(char*));//4

	printf("%d\n", sizeof(arr));//40
	printf("%d\n", sizeof(int[10]));//数组的类型int [10]  去掉数组名剩下就是它的类型

	return 0;
}